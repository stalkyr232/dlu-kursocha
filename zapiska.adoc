---
title: Курсовая работа
---

= Курсовая работа

[text-right]
--
 Выполнил студент группы КЭ-413
 Ульданов Данил
--

== Глава 1. Анализ требований

Необходимо разработать устройство имитации работы датчика расхода SEN02141B.

Техническое задание:
Устройство должно по изменению сопротивления резистора на плате
расширения изменять частоту генерации сигналов на порту микроконтроллера.

Формула изменения частоты от напряжения на переменном резисторе:

F = Af + Bf * code ,

где Af,Bf - коэффициенты полинома, насчитанные исходя из предположения, что код
1В соответствует 10Гц, код 3В соответствует 55Гц
code – код АЦП ; F - частота

▪ При напряжении менее 0.9 V частота генерации должна быть 0Гц.

▪ АЦП должно работать в режиме DMA

▪ Период измерения напряжения должен быть 50ms

К измеренному напряжению должен быть применен фильтр вида:

tau = int ((1-e^(-dt/(R*C)), RC > 0 sec), (1, RC<= 0 sec))
"FilteredValue" = "OldFiltered" + ("Value" - "OldValue") * tau,

где dt - 100 мс;

Value – текущее нефильтрованное измеренное значение напряжения;

oldValue - предыдущее фильтрованное значение.

▪ Устройство должна использоваться плату Accessories Shield или Analog Test Shield

▪ Для вывода частоты использовать порт TBD

=== Формула изменения частоты от напряжения на переменном резисторе

Для начала определим где находиться переменный резистор и его параметры.
Используемая плата расширения это Accessory Shield, Плата расширения для Arduino с популярными периферийними модулями на плате и Xbee разъемом
Даташит для нее был найден на сайте www.chipdip.ru

Stm32F411RE является основным управляющим чипом платы разработки XNucleo. Она имеет широкий
диапазон напряжений питания, поддерживая напряжение питания 3,3 В и 5 В.
Благодаря встроенному 12-разрядному АЦП
он может обеспечить 2 ^ 12 = 4096. При напряжении питания 3,3 В
разрешение составляет до 4096 мВ / 3300 = 1,24121212121212 мВ. Когда значение равно 1, это соответствует
выходному напряжению 1,24121212121212 мВ.

Встроенный потенциометр с регулировкой 10k необходим что
бы менять напряжение которое приходит на АЦП
Потенциометр находиться на пине ЫЫЫ

При изменении сопротивления потенциометра меняется код который выдает АЦП.
Формула перевода кода АЦП в напряжение

U=A*B/C

где А – это полученный код от АЦП

В – это опорное напряжение которое подается на АЦП, так как
АЦП питается от того же напряжения что и микроконтрорлер это напряжение 3.3В

С – это разрядность АЦП у нас это 12 разрядный АЦП

Таким образом получаем следующую формулу

U=A*3.3В/4096

Упростим и получим

U=A*0,8056640625, мВ



F = Af + Bf * code,

Коэффициент Аf это 22,5 Bf это 13

При коде АЦП 1117 и меньше отключаем генерацию сигнала.

=== АЦП с возможностью прямого доступа к памяти
DMA (Direct Memory Access) - это модуль,
который позволяет устройствам ввода-вывода (например, периферийным устройствам)
напрямую обмениваться данными с памятью без участия центрального процессора (CPU).
DMA используется для ускорения передачи данных между периферийными устройствами и памятью,
что позволяет снизить нагрузку на CPU и улучшить производительность системы.

DMA-контроллер представляет собой аппаратный блок,
который управляет передачей данных между периферийными устройствами и памятью.
Он имеет свою собственную очередь задач, которые выполняются автономно от CPU.
Когда периферийное устройство готово к передаче данных, оно посылает запрос на DMA-контроллер,
который запускает передачу данных между устройством и памятью.

Для использования DMA необходимо настроить контроллер DMA и настроить периферийное устройство для работы с DMA.
Настройка контроллера DMA включает в себя настройку его режима работы,
выбор канала DMA, настройку адресов и размеров передаваемых данных.
Настройка периферийного устройства для работы с DMA включает в себя выбор канала DMA,
настройку режима работы и настройку адресов и размеров передаваемых данных.

В целом, DMA - это мощный инструмент для ускорения передачи данных между периферийными устройствами и памятью.
Он позволяет снизить нагрузку на CPU и увеличить производительность системы.

=== Цифровая фильтрация сигнала


Цифровые фильтры - это цифровые устройства, которые используются для обработки сигналов.
Они могут быть реализованы как аппаратные, так и программные средства.
FIR и IIR являются двумя основными типами цифровых фильтров.

FIR (Finite Impulse Response) фильтры имеют конечный размер импульсной характеристики.
Это означает, что выходной сигнал зависит только от конечного числа входных сигналов.

FIR фильтры отлично подходят для обработки сигналов среднего и высокого уровня и имеют линейную фазу.
Они также очень устойчивы к вычислительным ошибкам и отлично подходят для реализации на цифровых процессорах.

IIR (Infinite Impulse Response) фильтры имеют бесконечную импульсную характеристику.
Это означает, что выходной сигнал зависит от всех предыдущих входных сигналов и выходных сигналов.

IIR фильтры хорошо подходят для обработки низкочастотных сигналов, таких как звук, видео и изображения.
Они обладают нелинейной фазой, что может приводить к искажениям в выходном сигнале.

В целом, FIR фильтры обладают линейной фазой, лучшей разрешающей способностью и устойчивостью к вычислительным ошибкам, а IIR фильтры обладают ограниченной пропускной способностью и нелинейной фазой, но могут использоваться для обработки низкочастотных сигналов.


[stem]
++++
tau = int ((1-e^(-dt/(R*C)), RC > 0 sec), (1, RC<= 0 sec))



"FilteredValue" = "OldFiltered" + ("Value" - "OldValue") * tau,
++++

Данная формула определяет экспоненциальный фильтр для измерения напряжения.
В качестве фильтра используется

RC-цепь,

где R - это сопротивление,

C - емкость,

а dt - время дискретизации.

где dt - 100 мс;

Value – текущее нефильтрованное измеренное значение напряжения;

oldValue - предыдущее фильтрованное значение.

Это IIR (Infinite impulse response) фильтр,
потому что выходной сигнал зависит от предыдущих значений входного и выходного сигналов.

На основании этой формулы можно вычислить значение отфильтрованного напряжения (FilteredValue)
на основе предыдущего значения (OldFiltered), текущего значения (Value) и параметров фильтра (R и C).

Экспоненциальный фильтр, который был описан по формуле, является простым и эффективным методом сглаживания данных.
Он широко используется в различных областях, таких как обработка сигналов, управление двигателями,
электроника и другие области.

Также стоит отметить, что параметры R и C влияют на скорость реакции фильтра и на уровень его подавления.
Если выбрать большое значение RC, то фильтр будет медленно реагировать на изменения входного сигнала и
более глубоко подавлять высокочастотные помехи. Если же выбрать маленькое значение RC,
то фильтр будет быстро реагировать на изменения входного сигнала, но меньше подавлять шум.

Таким образом, правильный выбор параметров фильтра RC позволяет достичь необходимого уровня сглаживания
с минимальными помехами и задержкой

В формуле "tau" представляет собой постоянную времени фильтра, которая определяется параметрами R и C. Если RC > 0, то постоянная времени равна RC, а если RC <= 0, то постоянная времени равна 1.

"FilteredValue" - это текущее сглаженное значение, которое рассчитывается на основе предыдущего значения "OldFiltered" и текущего значения "Value", умноженного на постоянную времени фильтра.

Формула "FilteredValue" = "OldFiltered" + ("Value" - "OldValue") * tau" показывает, что новое сглаженное значение зависит от предыдущего сглаженного значения и разницы между текущим и предыдущим значениями. Чем больше постоянная времени фильтра, тем медленнее изменяется сглаженное значение и тем больше шумов оно удаляет


=== ОСРВ
Согласно заданию необходимо проводить измерения каждые 50 мс.
Для этих целей можно использовать операционную систему реального времени (ОСРВ).
С помощью ОСРВ можно создать несколько разнородных задач, выполнение которых будет
происходить в заданные периоды времени. +


Операционная система реального времени (RTOS)  - это программное обеспечение,
которое управляет и координирует выполнение задач в режиме реального времени.
RTOS ставит задачи и события в порядке очереди и позволяет процессору STM32 работать максимально эффективно
и точно в соответствии с требованиями предъявляемыми к режиму реального времени.

Операционная система реального времени используется для обработки событий и задач,
требующих срочного выполнения, таких как обработка данных в реальном времени, связанных с датчиками
и исполнительными устройствами. Она обеспечивает непрерывную работу микроконтроллера STM32 в режиме
реального времени, контролируя приоритеты и сроки выполнения каждой задачи и учитывая внешние события.

Основные принципы операционной системы реального времени для микроконтроллеров STM32 включают:

1. Организация задач в порядке выполнения по приоритету;
2. Вычисление задержек выполнения задач;
3. Контроль времени реакции на внешние события;
4. Использование прерываний для реакции на события;
5. Распределение ресурсов среди задач;
6. Обеспечение безопасности и защиты от потери данных.


Итак, составим задачи для ОСРВ:

1. Измерение напряжения при помощи АЦП и запись полученных
данных при помощи DMA в регистры памяти микроконтроллера.
Данная задача осуществляет считывание с резистора значения в виде кода АЦП,
переводит это напряжение в значение частоты для генерации и посчитанное значение
заносит в память микроконтроллера для другой задачи.

2. Задача фильтрации измеренного напряжения.
Каждые 50 мс данная задача берёт измеренное напряжение из памяти
и применяет к ниму фильтр вида

[stem]
++++
tau = int ((1-e^(-dt/(R*C)), RC > 0 sec), (1, RC<= 0 sec))



"FilteredValue" = "OldFiltered" + ("Value" - "OldValue") * tau,

++++
где dt - 100 мс;
Value – текущее нефильтрованное измеренное значение напряжения;
oldValue - предыдущее фильтрованное значение,
а после записывает в память новое значение напряжения.

3. Перевод значения напряжение в значение частоты для генерации сигнала.
Данная задача должна посчитать по формуле Частота = 0,0225 * U - 13
это значение частоты в Герцах необходимо генерировать,
Затем она выдает эту частоту  на порте TBD.

4. Генерация сигнала заданной частоты.

=== UML-диаграмма

[plantuml]

----
class Frequency
{

}
class ITread
{
  + Execute(): void
}

class Filter
{
- R:float
- C:float
- _oldFiltered: IDataSource&
- _value: IDataSource&
- _oldValue: IDataSource&

+ filtere(value: IDataSource,oldValue: IDataSource )
}

class ADC
{
- codePresent: uint32_t
  + ADC()
  + Start():void
}

class IMeasureParameter
{
   + Calculate (): float
}

class Voltage_Task
{
- _parameter: IMeasureParameter
  + Voltage_Task(parameter: IMeasureParameter)
}

class Voltage
{
- b:float = 0,8056640625
- _codePresent: IDataSource&
- _codePast: IDataSource&
+ voltage(code: IDataSource)

}



class IDataSource
{
  + GetData(): float
}



ITread<|-- Voltage_Task

ITread<|-- Generator_Task

IDataSource<|--ADC

IMeasureParameter <|-- Voltage

Voltage_Task o-- IMeasureParameter
Voltage o-- IDataSource
IMeasureParameter <|-- Filter
IMeasureParameter <|-- Frequency
Generator_Task o-- Frequency



----





