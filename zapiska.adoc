---
title: Курсовая работа
---

= Курсовая работа

[text-right]
--
 Выполнил студент группы КЭ-413
 Ульданов Данил
--

== Глава 1. Анализ требований

Необходимо разработать устройство имитации работы датчика расхода SEN02141B.

Техническое задание:
Устройство должно изменять частоту генерации в зависимости от напряжения.

Формула изменения частоты от напряжения на переменном резисторе:
[stem]
++++
F = Af + Bf * code ,
++++
где Af,Bf - коэффициенты полинома, насчитанные исходя из предположения, что код
1В соответствует 10Гц, код 3В соответствует 55Гц
code – код АЦП ; F - частота

▪ При напряжении менее 0.9 V частота генерации должна быть 0Гц.

▪ АЦП должно работать в режиме DMA

▪ Период измерения напряжения должен быть 50ms

К измеренному напряжению должен быть применен фильтр вида:
[stem]
++++
tau = int ((1-e^(-dt/(R*C)), RC > 0 sec), (1, RC<= 0 sec))
"FilteredValue" = "OldFiltered" + ("Value" - "OldValue") * tau,
++++
где dt - 100 мс;

Value – текущее нефильтрованное измеренное значение напряжения;

oldValue - предыдущее фильтрованное значение.

▪ Устройство должна использоваться плату Accessories Shield или Analog Test Shield

▪ Для вывода частоты использовать порт TIM1 Chanel 4, pin — PA11

=== Формула изменения частоты от напряжения на переменном резисторе

Для начала определим где находиться переменный резистор и его параметры.
Используемая плата расширения это Accessory Shield, Плата расширения для Arduino с популярными периферийними модулями на плате и Xbee разъемом
Даташит для нее был найден на сайте www.chipdip.ru

Stm32F411RE является основным управляющим чипом платы разработки XNucleo. Она имеет широкий
диапазон напряжений питания, поддерживая напряжение питания 3,3 В и 5 В.
Благодаря встроенному 12-разрядному АЦП
он может обеспечить 2 ^ 12 = 4096. При напряжении питания 3,3 В
разрешение составляет до 3300 мВ / 4096 = 0,8 мВ. Когда значение равно 1, это соответствует
выходному напряжению 0,8 мВ.

Встроенный потенциометр с регулировкой 10k необходим что
бы менять напряжение которое приходит на АЦП
Потенциометр находиться на пине PA0

При изменении сопротивления потенциометра меняется код который выдает АЦП.
Формула перевода кода АЦП в напряжение
[stem]
++++
U=code*B/C
++++
где code – это полученный код от АЦП

В – это опорное напряжение которое подается на АЦП, так как
АЦП питается от того же напряжения что и микроконтрорлер это напряжение 3.3В

С – это разрядность АЦП у нас это 12 разрядный АЦП

Таким образом получаем следующую формулу
[stem]
++++
U=code*3.3В/4096
++++
Упростим и получим
[stem]
++++
U=code*0,8 мВ
++++

Для расчета частоты которую необходимо генерировать
на порте используем следующую формулу:

[stem]
++++
F = Af + Bf * code,
++++

Для расчета коэффициентов Af и Bf необходимо воспользоваться системой двух уравнений с двумя неизвестными.

Так как при code = 1000, F = 10, первое уравнение будет выглядеть следующим образом:
[stem]
++++
10 = Af + Bf * 1000
++++
Так как при code = 3000, F = 55, второе уравнение будет выглядеть следующим образом:
[stem]
++++
55 = Af + Bf * 3000
++++
Из первого уравнения можно выразить Af:
[stem]
++++
Af = 10 - 1000 * Bf
++++
Подставляя этот коэффициент во второе уравнение, получим:
[stem]
++++
55 = (10 - 1000 * Bf) + Bf * 3000

55 = 10 + 2000 * Bf

Bf = (55 - 10) / 2000 = 0.0225
++++
Таким образом, коэффициенты Af и Bf равны соответственно -22.5 и 0.0225.

Я рассчитал коэффициенты, используя значение F при минимальном и максимальном значении code.
Коэффициент Af был вычислен, используя первое уравнение.
Далее, подставляя коэффициент Af и известные значения F и code во второе уравнение, я вычислял коэффициент Bf.

Так как при напряжении 0,9В нужно отключить генерацию сигнала необходимо пересчитать это напряжение в код АЦП.
[stem]
++++
code=900мВ/0,8=1125
++++

При коде АЦП 1125 и меньше отключаем генерацию сигнала.

=== АЦП с возможностью прямого доступа к памяти
DMA (Direct Memory Access) - это модуль,
который позволяет устройствам ввода-вывода (например, периферийным устройствам)
напрямую обмениваться данными с памятью без участия центрального процессора (CPU).
DMA используется для ускорения передачи данных между периферийными устройствами и памятью,
что позволяет снизить нагрузку на CPU и улучшить производительность системы.

DMA-контроллер представляет собой аппаратный блок,
который управляет передачей данных между периферийными устройствами и памятью.
Он имеет свою собственную очередь задач, которые выполняются автономно от CPU.
Когда периферийное устройство готово к передаче данных, оно посылает запрос на DMA-контроллер,
который запускает передачу данных между устройством и памятью.

Для использования DMA необходимо настроить контроллер DMA и настроить периферийное устройство для работы с DMA.
Настройка контроллера DMA включает в себя настройку его режима работы,
выбор канала DMA, настройку адресов и размеров передаваемых данных.
Настройка периферийного устройства для работы с DMA включает в себя выбор канала DMA,
настройку режима работы и настройку адресов и размеров передаваемых данных.

В целом, DMA - это мощный инструмент для ускорения передачи данных между периферийными устройствами и памятью.
Он позволяет снизить нагрузку на CPU и увеличить производительность системы.

=== Цифровая фильтрация сигнала

Цифровой фильтр – это вычислительное устройство (физическая система или программа для ПЭВМ),
реализующее заданный алгоритм избирательной обработки сигналов в реальном масштабе времени.
Классификация фильтров осуществляется по полосе пропускания (ФНЧ, ФВЧ, ПФ, РФ) и по типу фильтра
(Баттерворта и Чебышева).

По полосе пропускания:

ФНЧ – аналоговый или электрический фильтр,
эффективно пропускающий частотный спектр сигнала ниже частоты среза и
уменьшающий частоту спектра сигнала выше этой частоты. Степень подавления зависит от фильтра.

ФВЧ – электрический или другой фильтр, пропускающий высокие частоты спектра входного сигнала,
при этом подавляя частоты спектра сигнала меньше, чем частота среза.


[stem]
++++
tau = int ((1-e^(-dt/(R*C)), RC > 0 sec), (1, RC<= 0 sec))



"FilteredValue" = "OldFiltered" + ("Value" - "OldValue") * tau,
++++

Данная формула определяет экспоненциальный фильтр для измерения напряжения.
В качестве фильтра используется

RC-цепь,

где R - это сопротивление,

C - емкость,

а dt - время дискретизации.

где dt - 100 мс;

Value – текущее нефильтрованное измеренное значение напряжения;

oldValue - предыдущее фильтрованное значение.

Это IIR (Infinite impulse response) фильтр,
потому что выходной сигнал зависит от предыдущих значений входного и выходного сигналов.

На основании этой формулы можно вычислить значение отфильтрованного напряжения (FilteredValue)
на основе предыдущего значения (OldFiltered), текущего значения (Value) и параметров фильтра (R и C).

Экспоненциальный фильтр, который был описан по формуле, является простым и эффективным методом сглаживания данных.
Он широко используется в различных областях, таких как обработка сигналов, управление двигателями,
электроника и другие области.

Также стоит отметить, что параметры R и C влияют на скорость реакции фильтра и на уровень его подавления.
Если выбрать большое значение RC, то фильтр будет медленно реагировать на изменения входного сигнала и
более глубоко подавлять высокочастотные помехи. Если же выбрать маленькое значение RC,
то фильтр будет быстро реагировать на изменения входного сигнала, но меньше подавлять шум.

Таким образом, правильный выбор параметров фильтра RC позволяет достичь необходимого уровня сглаживания
с минимальными помехами и задержкой

В формуле "tau" представляет собой постоянную времени фильтра, которая определяется параметрами R и C. Если RC > 0, то постоянная времени равна RC, а если RC <= 0, то постоянная времени равна 1.

"FilteredValue" - это текущее сглаженное значение, которое рассчитывается на основе предыдущего значения "OldFiltered" и текущего значения "Value", умноженного на постоянную времени фильтра.

Формула "FilteredValue" = "OldFiltered" + ("Value" - "OldValue") * tau" показывает, что новое сглаженное значение зависит от предыдущего сглаженного значения и разницы между текущим и предыдущим значениями. Чем больше постоянная времени фильтра, тем медленнее изменяется сглаженное значение и тем больше шумов оно удаляет


=== ОСРВ
Операционная система реального времени (RTOS) предназначена, для того чтобы обеспечить скорость обработки данных,
обеспечение реакции на опрделенное воздействие за отведенный квант времени.


Согласно заданию необходимо проводить измерения каждые 50 мс.
Для этих целей можно использовать операционную систему реального времени (ОСРВ).
С помощью ОСРВ можно создать несколько разнородных задач, выполнение которых будет
происходить в заданные периоды времени. +

Итак, составим задачи для ОСРВ:

1. Расчет напряжения при помощи АЦП, его фильтрация и запись полученных
данных при помощи DMA в регистры памяти микроконтроллера.
Данная задача осуществляет расчет значения в виде кода АЦП, применяет к нему фильтр вида

[stem]
++++
tau = int ((1-e^(-dt/(R*C)), RC > 0 sec), (1, RC<= 0 sec))



"FilteredValue" = "OldFiltered" + ("Value" - "OldValue") * tau,

++++
где dt - 100 мс;
Value – текущее нефильтрованное измеренное значение напряжения;
oldValue - предыдущее фильтрованное значение,
а после записывает в память новое значение напряжения.

затем переводит это напряжение в значение частоты для генерации по следующей формуле

[stem]
++++
F = Af + Bf * code,
++++
Af и Bf равны соответственно -22.5 и 0.0225.
это значение частоты в Герцах необходимо генерировать,
Затем она выдает эту частоту  на порте PA11.


=== UML-диаграмма

[plantuml]

----
class Frequency
{

}
class ITread
{
  + Execute(): void
}

class Filter
{
- R:float
- C:float
- _oldFiltered: IDataSource&
- _value: IDataSource&
- _oldValue: IDataSource&

+ filtere(value: IDataSource,oldValue: IDataSource )
}

class IFilter
{
+ Filter(value:float):float
}

class ADC
{
- codePresent: uint32_t
  + ADC()
  + Start():void
}

class IMeasureParameter
{
   + Calculate (): float
}

class Voltage_Task
{
- _parameter: IMeasureParameter
  + Voltage_Task(parameter: IMeasureParameter)
}

class Voltage
{
- b:float = 0,8056640625
- _codePresent: IDataSource&
- _codePast: IDataSource&
+ voltage(code: IDataSource)

}



class IDataSource
{
  + GetData(): float
}



ITread<|-- Voltage_Task

ITread<|-- Generator_Task

IDataSource<|--ADC

IMeasureParameter <|-- Voltage

Voltage_Task o-- IMeasureParameter
Voltage o-- IDataSource
IMeasureParameter o-- IFilter
IMeasureParameter <|-- Frequency
Generator_Task o-- Frequency

IFilter <|-- Filter

----





